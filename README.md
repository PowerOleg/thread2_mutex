+1)std::lock_guard<std::mutex> lg1(m1) - предсказуемый и !при исключении разблокирует mutex! 
По принципу RAII блокирует от начала скобочек до конца скобочки(области видимости).
Принимает только один mutex

+2)std::scoped_lock<...> sl1(m1, m2)—это улучшенная версия std::lock_guard<std::mutex> lg1(m1),
конструктор которого блокирует произвольное количество мьютексов в фиксированном порядке. (c++ 17)

-3)используя m1.lock; m1.unlock; при ислючении mutex не разблокируется! 

4)std::lock l1(m1, m2) имеет встроенный алгоритм недопущения deadlock(сомнительно) и работает с несколькими mutex. для разблокировки нужно писать l1.unlock();

+5)std::unique_lock<std::mutex> lk(m1); lk.lock(); lk.unlock(); когда надо тогда и блочит

6)std::condition_variable

